---
layout: post
title:  "On SNIP-12"
---

SNIP-12 is Starknet Improvement Proposal 12, which is heavily based on [EIP712](https://eips.ethereum.org/EIPS/eip-712). Both proposals define the standard for hashing and signing typed structured data instead of hexadecimal string that does not make sense to users when signing a transaction in a browser extension.

Having first hand experience in implementing SNIP-12, I would like to share what I've discovered and learned along the way.

My starting point is [OpenZeppelin docs](https://docs.openzeppelin.com/contracts-cairo/0.11.0/guides/snip12), a walkthrough on the full implementation of the signature signing in Cairo language.

Here is the flow: you'll generate an offchain signature using any language, for example, Golang, Javascript and then use Cairo to verify the signature on-chain.

This post focuses on on-chain verification.

Before we begin, I'd like to state tool versions that I'm using:
```toml
starknet = "2.8.2"
snforge_std = "0.30.0"
openzeppelin = "0.17.0"
```

```
go 1.23.2

require github.com/NethermindEth/starknet.go v0.7.3
```


## How to generate message type hash

```rust
const MESSAGE_TYPE_HASH: felt252 = 0xa2a7036c1f406af7c47722b209f23bd2f2d6ac21423c8c73bd92cf28409ee2;

#[derive(Copy, Drop, Hash)]
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u128
}
```

This is the example provided by OpenZeppelin. If you compare Message struct with SNIP-12 specification. `u64` type is not recognised. You will not be able to generate the same message hash using Python, Go and Typescript (i.e. any other languages other than Cairo).

```rust
let message_type_hash = selector!(
    "\"Message\"(\"recipient\":\"ContractAddress\",\"amount\":\"u256\",\"nonce\":\"felt\",\"expiry\":\"u64\")\"u256\"(\"low\":\"felt\",\"high\":\"felt\")"
);
```

This yields `MESSAGE_TYPE_HASH` above.

But in Golang, you'll get a panic error:

```
panic: fail to unmarshal TypedData: can't parse type u64
```

I concluded that the Message struct defined in Cairo does not necessarily need to follow SNIP-12 defined data types, as long as the `MESSAGE_TYPE_HASH` is the same from your off-chain and on-chain signing.

Nevertheless, it is best to make the struct similar. Otherwise you might end up with more type inconsistencies.

The correct off-chain message that is signed will look something like this:

```go
package main

import (
	"encoding/json"
	"fmt"

	"github.com/NethermindEth/starknet.go/typedData"
)

func main() {
	// JSON data defined directly in the code
	jsonData := `{
		"types": {
			"StarknetDomain": [
				{ "name": "name", "type": "shortstring" },
				{ "name": "version", "type": "shortstring" },
				{ "name": "chainId", "type": "shortstring" },
				{ "name": "revision", "type": "shortstring" }
			],
			"Message": [
				{ "name": "recipient", "type": "ContractAddress" },
				{ "name": "amount", "type": "u256" },
				{ "name": "nonce", "type": "felt" },
				{ "name": "expiry", "type": "timestamp" }
			]
		},
		"primaryType": "Message",
		"domain": {
			"name": "StarkNet Mail",
			"version": "1",
			"chainId": "0x534e5f5345504f4c4941",
			"revision": "1"
		},
		"message": {
			"recipient": "0xd392b0c0500700d02d27ab30805ec80ddd3320ff",
			"amount": "100.00",
			"nonce": 0,
			"expiry": 1734859800
		}
	}`

	var ttd typedData.TypedData
	err := json.Unmarshal([]byte(jsonData), &ttd)
	if err != nil {
		panic(fmt.Errorf("fail to unmarshal TypedData: %w", err))
	}
	messageTypeHash, err := ttd.GetTypeHash("Message")
	if err != nil {
		panic(fmt.Errorf("fail to get message type hash: %w", err))
	}
	fmt.Println("message type hash:", messageTypeHash)
  // message type hash: 0xa2a7036c1f406af7c47722b209f23bd2f2d6ac21423c8c73bd92cf28409ee2
}
```
https://goplay.tools/snippet/HKBsXawjuLx


Note that `expiry` field can either be u128 or timestamp as the latter will be treated like u128, represented in seconds[^1]. In the case of `expiry`, defining it as `timestamp` is clearer than `u128`.

It'll be helpful to note that `u256` used in `amount` field will be split into low/high 128 bits[^1].

The second problem faced is forming the selector string. It is unintuitive especially converting u256 to an object of low and high values.

I would suggest to use Golang library since it has the least amount of setup needed[^2].

So yes, if you've noticed, the message type hash generated is different from the Cairo example OpenZeppelin provided. So you will need to update `MESSAGE_TYPE_HASH` and `expiry` data type.

 ```diff
-const MESSAGE_TYPE_HASH: felt252 = 0x120ae1bdaf7c1e48349da94bb8dad27351ca115d6605ce345aee02d68d99ec1;
+const MESSAGE_TYPE_HASH: felt252 = 0xa2a7036c1f406af7c47722b209f23bd2f2d6ac21423c8c73bd92cf28409ee2;

 #[derive(Copy, Drop, Hash)]
 struct Message {
     recipient: ContractAddress,
     amount: u256,
     nonce: felt252,
-    expiry: u64
+    expiry: u128
 }
 ```

## Starknet Domain affects final message hash

If you notice the example above, we are using revision 1 which corresponds to `Starknet Domain` domain object[^3].

Interestingly, the struct hash of "domain" object is different between Cairo and Golang.

```json
"domain": {
  "name": "StarkNet Mail",
  "version": "1",
  "chainId": "0x534e5f5345504f4c4941",
  "revision": 1
}
```

```go
// continuing from above Go code
domainHash, err := ttd.GetStructHash(ttd.Revision.Domain())
	if err != nil {
		panic(fmt.Errorf("fail to get struct hash: %w", err))
	}
	fmt.Println("domain hash:", domainHash)
  // 0x6c09a2d2b4766fc27839cddedc0bf21408750397698671710b1ea8fd7761287
```

Cairo:
```rust
let domain = StarknetDomain {
    name: metadata::name(),
    version: metadata::version(),
    chain_id: get_tx_info().unbox().chain_id,
    revision: 1
};
println!("domain: {:?}", domain);
println!("domain_struct_hash: {:?}", domain.hash_struct());

// STDOUT: domain: StarknetDomain { name: 6611955555956948379282337524076, version: 49, chain_id: 393402133025997798000961, revision: 1 }
// STDOUT: domain_struct_hash: 642745170559712649122281357821340941879369528611034460916757525855769477160

// Convert decimal to hex
// domain_struct_hash: 0x16BC7E7664F47B684E3FC1CD8EE48CAFFEEC098FC85CE1A024E820AA8A04028
// It does not match `0x6c09a2d2b4766fc27839cddedc0bf21408750397698671710b1ea8fd7761287`
```

Any guesses? Turns out, you need a `v` prefix in `version` field for cairo to compute the same hash as the other languages.

```diff
"domain": {
  "name": "StarkNet Mail",
-  "version": "1",
+  "version": "v1",
  "chainId": "0x534e5f5345504f4c4941",
  "revision": 1
}
```

Re-running Go,

```
✦ ❯ go run main.go
domain hash: 0x4d66974991a172368812272d15c74c7894b3cedc08f36c576d837a47515e425
```

Re-running Cairo,

```bash
STDOUT: domain: StarknetDomain { name: 6611955555956948379282337524076, version: 30257, chain_id: 393402133025997798000961, revision: 1 }
STDOUT: domain_struct_hash: 2188084493039379785443876450040401224928080773759018043323204526752587441189
# 0x4D66974991A172368812272D15C74C7894B3CEDC08F36C576D837A47515E425
```

The domain hash matches! Isn't that interesting?

Looking at OpenZeppelin cairo source code,

```rust
// From https://github.com/OpenZeppelin/cairo-contracts/blob/v0.17.0/packages/utils/src/cryptography/snip12.cairo#L35-L40
impl StructHashStarknetDomainImpl of StructHash<StarknetDomain> {
    fn hash_struct(self: @StarknetDomain) -> felt252 {
        let hash_state = PoseidonTrait::new();
        hash_state.update_with(STARKNET_DOMAIN_TYPE_HASH).update_with(*self).finalize()
    }
}
```

I can't figure out where the prefix `v` is taken into account when calculating the hash.

Anyway, if you ever find yourself implementing SNIP-12. I hope you find this useful.




# Footnotes

[^1]: See type definitions in [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md#how-to-work-with-each-type)

[^2]: I'm using Golang as a language choice in this post. You can use Python or Typescript starknet libraries as well.

[^3]: See domain separator in [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md#domain-separator)